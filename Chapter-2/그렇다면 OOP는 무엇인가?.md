# 그렇다면 OOP는 무엇인가?

OOP는 엘런 케이가 제시한 새로운 패러다임이다. 학부 시절 생물학을 전공한 그가 객체가 독립적으로 자율성있게 서로 소통하면 어떨까? 라는 생각으로 접근한 것이 OOP다.

그렇다면 생명과 소프트웨어가 비슷한 임무를 수행할 수 있을까?

생명체은 다수의 세포를 가지고 있다. 특정 [ **책임** ] 을 질 수 있는 작은 단위의 세포들은 각각의 다른 [ **역할** ] 을 가진 세포들과 [ **협력** ]을 해서 복잡한 생명체를 이룬다.

세포의 목적은 생명체를 유지하고 움직이게 하는 것이라고 볼 수 있다.

이제 소프트웨어를 살펴보자. 소프트웨어의 목적은 무엇일까? 대개 사람들에게 어떠한 기능을 제공하기 위함이 소프트웨어의 목적이라고 볼 수 있다. 모든 프로그래머들은 알겠지만 어떠한 기능을 제공하기 위해서 제공해야할 코드는 엄청나게 많다. 이 복잡한 소프트웨어를 [ **책임** ], [ **역할** ], [ **협력** ]을 하기위한 작은 단위의 객체들로 구성한다면 소프트웨어를 이해하기 더 쉽지 않을까?

# 결국엔 [ **책임** ], [ **역할** ], [ **협력** ]

지금의 OOP는 우리에게 많은 지식을 요구한다. 클래스, 인스턴스, 상속, 캡슐화, 추상화, 다형성, SOLID 원칙 등등.. 그 많은 지식들을 쌓을 수 있게끔 기반을 다져놓은 개념은 [ **책임** ], [ **역할** ], [ **협력** ]에 있다는 것이다. 그 다음으로 앨런 케이가 주장하기를 OOP의 본질인 캡슐화, 메시징, 동적 바인딩이 있다.

간단한 예제를 만들어보자.

# 캡슐화, 메시징, 동적 바인딩

당신은 서점에 가서 객체지향에 관련된 책을 찾으려고 한다.

당신이 책을 찾으려면 서점의 컴퓨터를 이용해 그와 관련된 책을 찾으면 된다.

이때 객체를 당신, 서점의 컴퓨터, 서점 컴퓨터 서버, 책이라고 생각해보자.

서점의 컴퓨터는 한 가지의 일을 수행한다. 바로 서점 컴퓨터 서버에 데이터를 조회하는 것이다. 그리고 당신은 서점의 컴퓨터에게 객체지향에 관련된 정보를 요청할 것이다.

당신 ----- getBooksData(title) ------> 서점 컴퓨터

이 과정을 메시징이라고 한다.

당신은 서점 컴퓨터에게 메시징을 보냈고 메시지를 받은 서점 컴퓨터는 어떠한 과정을 거쳐서 다시 컴퓨터 서버에 요청을 보낼 것이다. 이때 당신은 서점 컴퓨터가 어떠한 과정을 거치는 지 알 수가 없다. 그저 서점 컴퓨터에게 메시징을 보내면 서점에 있는 책의 데이터를 보여준다는 것을 알고 있다.

서점 컴퓨터 ----- getBooksData(title) ------> 컴퓨터 서버

서점 컴퓨터는 책에 대한 정보를 컴퓨터 서버에게서 받아서 당신에게 제공한다.

방금 당신은 책을 찾기 위해서 서점 컴퓨터와 컴퓨터 서버라는 객체들과 [ **책임** ], [ **역할** ], [ **협력** ] 이라는 행동을 했다. 서로가 맡은 역할에 책임을 가지고 협력을 하는 와중에 당신은 서점 컴퓨터가 어떤 원리로 컴퓨터 서버에게 데이터를 요청하고 또 컴퓨터 서버는 어떤 원리로 데이터를 가져오는 지 알 필요가 있었나?

그렇지 않다.

당신은 그저 자판기에 원하는 데이터를 입력하면 해당하는 데이터를 받아올 수 있었다.

서점 컴퓨터는 화면에 무언가를 서점에 관련된 무언가를 띄우기 위한 데이터와 메서드로 구성되어있다. 이러한 구성으로 객체를 만드는 것을 캡슐화라고 한다. 만약 이 서점 컴퓨터의 주요 기능이 검색을 담당하는 것 하나만을 가지고 있다면, 당신에게 허락된 메서드 즉 당신이 이 서점 컴퓨터에게 보낼 수 있는 메시징은 getBooksData 밖에 없을 것이다.

그 외에 서점 컴퓨터가 가지고 있는 기능들은 당신에게 노출이 되지 않을 것이다. 이 서점 컴퓨터가 가지고 있는 데이터에 접근하는 방법은 서점 컴퓨터가 제공하는 getBooksData 라는 메서드 밖에 없는 것이다.

캡슐화가 잘 이루어져있는 객체는 이런식으로 객체가 가지고 있어야 할 데이터와 데이터를 변경 및 조회를 할 수 있는 메서드가 잘 구분되어 있다.

당신은 서점 컴퓨터를 이용해서 객체 지향을 검색했으나, 이용하고 있는 서점 컴퓨터에 문제가 있는지 어떠한 타이틀을 입력하더라도 error라는 문구만 나오고 있는 상황이다.

하지만 걱정할 필요 없다. 이 서점은 매우매우 거대해서 서점 컴퓨터가 무수히 많이 있다.

방금까지 이용했던 컴퓨터를 0라고 한다면 다른 컴퓨터인 N번 컴퓨터를 이용해서 원하는 책을 찾으면 된다.

이것을 동적 바인딩이라고 한다. 0번과 N번의 컴퓨터는 같은 기능을 하고 같은 데이터를 가지고 있지만, 우리는 이를 다른 컴퓨터라고 생각한다. 그리고 자연스럽게 0번이 안되면 다른 컴퓨터를 이용해야지라는 생각을 한다.

당신이 책의 데이터를 얻기 위해서 서점 컴퓨터를 이용할 때 메시지를 받는 서점 컴퓨터가 달라지더라도 동일한 결과를 받을 수 있는 것을 동적 바인딩이라고 한다.

# 결말

캡슐화는 한 객체가 어떠한 책임을 가지고 있고 어떠한 역할을 가지고 있는지 명확하게 구분하기 위해서 다른 객체는 접근할 수 없는 그 객체만이 가지고 있는 데이터, 데이터를 처리할 수 있는 메서드를 가지고 있는 것을 말한다. 당신이 서점 컴퓨터를 이용해서 데이터를 조작할 수 있는가?

그럴 수 없다. 당신은 오직 검색이라는 기능만을 가지고 있고 그 기능이 서점 컴퓨터라는 객체가 존재하는 목적이다.

메시징은 객체간의 소통을 위함이다. 소통을 하는 이유는 객체간에 협력을 하기 위해서다.

서점 컴퓨터가 컴퓨터 서버에게 getBooksData라는 메시징을 보내는 것. 당신이 서점 컴퓨터에게 getBooksData라는 메시징을 보내는 것, 두 가지 모두 메시징이고 객체간의 소통이다.

각 객체는 메시징을 처리하는 방법을 알 수가 없다 그 방법은 오직 메시지를 받는 객체만이 알고 있다.

서버 컴퓨터가 책에 관한 데이터를 보내줄 때, 데이터베이스에 저장된 값을 가져올 것인지 서버 컴퓨터 드라이브에 담겨져있는 데이터를 찾아서 줄 것 인지 우리는 알 필요가 없다. 그 일은 서버 컴퓨터 객체가 알아서 할 일이다. 객체는 다른 객체가 가지고 있는 책임을 어떻게 수행하는 지 알 필요가 없다.

[ **책임** ], [ **역할** ], [ **협력** ] 을 하는 이유는 복잡한 세계를 작은 단위로써 이해하기 위함이다. 나는 작은 단위의 세포들, 객체들이 크고 복잡한 생명체, 소프트웨어를 만들어 가는 것은 예쁜 구조라고 생각한다. 각 객체들이 역할에 대한 책임을 다하고 다른 객체들과 협력을 잘 하게 만들어주는 것 그것이 OOP다.
